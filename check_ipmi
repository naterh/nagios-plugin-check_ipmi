#!/bin/sh
# License: GPL v2
# Copyright (c) 2007 op5 AB
# Author: Hugo Hallqvist <dev@op5.com>
# Author: Elan Ruusamäe <glen@delfi.ee>
#
# Ported to pure shell by Elan Ruusamäe
# Original PHP version:
# http://git.op5.org/git/?p=nagios/op5plugins.git;a=blob_plain;f=check_ipmi.php;hb=HEAD
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Description: 
# Nagios plugin for locally checking hardware status (fans, voltage) via ipmi.
# It utilizes ipmitool to get results from kernel.
#
# Usage: check_ipmi <filename>
# 
# filename points to a file which is used as a cache for speeding up the check.

PROGRAM=${0##*/}
REVISION=$(echo '$Revision$' | sed -e 's/[^0-9.]//g')
PROGPATH=${0%/*}
ARGS="$*"
. $PROGPATH/utils.sh

# ipmitool needs to be with full path for sudo
ipmitool=/usr/bin/ipmitool
sudo=/usr/bin/sudo
modprobe=/sbin/modprobe

die() {
	eval local rc=\$STATE_$1
	[ "$rc" ] || rc=$STATE_UNKNOWN
	echo "$2"
	exit $rc
}

usage() {
	cat >&2 <<EOF
Usage: check_ipmi <filename>
       check_ipmi -S <filename>
       check_ipmi -c

     <filename> indicates the cache file for speeding up sensor readings.

    -c
       Checks if ipmitool can be used on this system
    -S
       Install sudo rules
EOF
}

# trim leading and trailing whitespace
trim() {
	echo "$*" | sed -e 's/^ *\| *$//g'
}

# checks if ipmitool is even usable on this system
check_ipmitool() {
	echo "Checking for IPMI..."
	$ipmitool chassis status >/dev/null 2>&1
	if [ $? != 0 ]; then
		echo "Chassis status failed, modprobing"
		$modprobe ipmi_si
		if [ $? != 0 ]; then
			echo "ERROR: ipmi_si module did not load, probably IPMI not present"
			echo "You can setup options to ipmi_so via modprobe.conf"
			exit 1
		fi
		$modprobe ipmi_devintf
		if [ $? != 0 ]; then
			echo "ERROR: ipmi_devintf module did not load"
			exit 1
		fi
		echo $?
	fi
	echo "Seems OK"
}

setup_sudoers() {
	check_ipmitool

	new=/etc/sudoers.$$.new
	umask 0227
	cat /etc/sudoers > $new
	cat >> $new <<-EOF

	# Lines matching CHECK_IPMI added by $0 $ARGS on $(date)
	User_Alias CHECK_IPMI=nagios
	CHECK_IPMI ALL=(root) NOPASSWD: $ipmitool sdr dump $cache_filename
	CHECK_IPMI ALL=(root) NOPASSWD: $ipmitool -S $cache_filename sdr
	EOF

	if visudo -c -f $new; then
		mv -f $new /etc/sudoers
		exit 0
	fi
	rm -f $new
	exit 1
}

create_sdr_cache_file() {
	local filename="$1"

	# return false if cache already exists (i.e, previous check running)
	[ -f "$filename" ] && return 1

	touch "$filename"
	# we run the dump in background
	$sudo $ipmitool sdr dump $filename >/dev/null &
	return 0
}

## Start of main program ##
while [ $# -gt 0 ]; do
	case "$1" in
	-h|--help)
		usage
		exit 0
		;;
	-V|--version)
		echo $PROGRAM $REVISION
		exit 0
		;;
	-c)
		check_ipmitool=1
		;;
	-S)
		setup_sudo=1
		;;
	*)
		cache_filename="$1"
		;;
	esac
	shift
done

if [ "$setup_sudo" = 1 ]; then
	setup_sudoers
fi

if [ "$check_ipmitool" = 1 ]; then
	check_ipmitool
	exit 0
fi

if [ -z "$cache_filename" ]; then
	die UNKNOWN "No databasename given."
fi

if [ ! -s "$cache_filename" ]; then
	if create_sdr_cache_file $cache_filename; then
		die UNKNOWN "New database initialized, no results yet."
	else
		die CRITICAL "Error initializing database."
	fi
fi

t=$(mktemp) || die CRITICAL "Can't create tempfile"
$sudo $ipmitool -S $cache_filename sdr > $t || die CRITICAL "Can't run ipmitool sdr"
# VRD 1 Temp       | 34 degrees C      | ok
# CMOS Battery     | 3.12 Volts        | ok
# VCORE            | 0x01              | ok

osensors=0
bsensors=0
bad_sensors=''
oIFS=$IFS IFS='|'
while read label result status; do
	case $(trim "$status") in
	ns)
		# skip ns (not supported)
		continue
		;;
	ok)
		# just count them
		osensors=$((osensors+1))
		;;
	*)
		bsensors=$((bsensors+1))
		label=$(trim "$label")
		result=$(trim "$result")
		status=$(trim "$status")
		bad_sensors="$bad_sensors($label, $status, $result) ";
		;;
	esac
done < $t
rm -f $t

if [ "$bad_sensors" ]; then
	die CRITICAL "$bsensors sensors bad: $bad_sensors"
fi

die OK "$osensors sensors OK"
